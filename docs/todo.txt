- lui
- fix stdout in circleci
- change time units to clock cycles
- int division
- int modulus
- prime numbers calculator
- maybe use a C/C++ -> RISC-V compiler, instead of writing assembler?
- instruction cache
- out of order execution
- cicd for iverilog reg_test
- cicd for timing
- cicd for verilator compilation
- floats: regs, mul, div, modulus, add, sub, beq, glt
- matrix multiplication
- check endian-ness relative to risc-v spec
- check spir-v vs risc-v
- gpu structure
- opencl
- change bits of address to 64-bit, to allow 16GB+ of memory
- create register file
- start create ALU functions, eg mul, div
- add area approximation to timing.py (eg count the number of cells :P)
- (use actual memory module?)

done:
- factorial calculator
- int multiplication
- measure timing/maximum clock speed somehow
- handle assigns in timing.py
- handle vector declarations in timing.py
- get timing.py working on src/proc.sv
- made a script to measure gate-level propagation delay for combinatorial module
- mv pseudoinstruction
- sum of integers from 0 to 5
- add 2 registers (and various other OP ops, such as shifts, and logical operators)
- migraet to use byte-addressing everywher (instead of word-addressing, eg for pc, and mem module instructions)
- loop from 5 to 0
- branch
- allow negative immediate for addi, and negative offset for store and load
- allow non-zero offset in store and load
- migrate HALT to be a virtual instruction that writes to location 1004
- migrate instructions to use risc-v op codes
- migrate away from `out` instructions
- load
- migrate out and outr to be virtual insturctions that store to 1000 instead
- use to write to memory location 1000 as 'out' command
- addi
- add store to memory (without offset)
- allow commas in instructions

things for gpu:
- get_local_id(), get_global_id()
- barrier
- global mem
- local mem

notes:
- I-type: register-immediate, rs1 . imm => rd (includes loads, where address is rs1 + signed offset)
- R-type: register-register operations, rs1 . rs2 => rd
- J-type: jumps. address in register + immediate offset
- B-type: conditional branches (offsets are in multiples of 2 bytes); based on rs1 and rs2; funct specifies eg BEQ, or BNE
- S-type: stores; rs2 is copied into memory. address is from rs1 + signed offset.
