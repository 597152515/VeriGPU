- branch
- jmp
- maybe use a C/C++ -> RISC-V compiler, instead of writing assembler?
- loop from 1 to 10?
- sum of integers from 1 to 10?
- factorial calculator
- prime numbers calculator
- matrix multiplication
- check endian-ness relative to risc-v spec
- check spir-v vs risc-v
- gpu structure
- opencl
- change bits of address to 64-bit, to allow 16GB+ of memory
- create register file
- start create ALU functions, eg mul, div
- measure timing/maximum clock speed somehow
- (use actual memory module?)

done:
- migrate instructions to use risc-v op codes
- migrate away from `out` instructions
- load
- migrate out and outr to be virtual insturctions that store to 1000 instead
- use to write to memory location 1000 as 'out' command
- addi
- add store to memory (without offset)
- allow commas in instructions
- handle different immediate int types (hex, dec)
- modify format of immediate hex values sliughlty, from abx to 0xab
- migrate to risc-v instruction layout (opcode in [6:0], rd in [11:7], rs1 in [19:15], rs2 in [24:20], immediate in [31:20])
- change bits of address to 32-bit
- change bits of data to 32-bit, to match risc-v 32I
- add asserts to progs somehow (maybe create test runners for each prog? or add an assert instruction? or use normal systemverilog driver/tests?)
- add halt
- factorize proc a bit better, so not so many indentation levels...
- fix prog3
- constants for ops and names
- add delay to memory module, to simulate wire latency
- comp


notes:
- I-type: register-immediate, rs1 . imm => rd (includes loads, where address is rs1 + signed offset)
- R-type: register-register operations, rs1 . rs2 => rd
- J-type: jumps. address in register + immediate offset
- B-type: conditional branches (offsets are in multiples of 2 bytes); based on rs1 and rs2; funct specifies eg BEQ, or BNE
- S-type: stores; rs2 is copied into memory. address is from rs1 + signed offset.
