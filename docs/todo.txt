- float mul
- matrix multiplication
- change reset to active low
- parallel instruction execution
- floats:  div, modulus, sub, beq, glt
- add piccie for gate level simulation to readme/docs
- simplify workflow piccie, just to have 'verilog' rather than filenames
- create register file
- fuse LUI and ADDI
- fuse LUI and JALR
- fuse AUIPC and JALR
- fuse DIV and MOD
- verilator driver file?
- maybe use a C/C++ -> RISC-V compiler, instead of writing assembler?
- instruction cache
- level 1 cache
- memory can have byte access (via cache)
- check endian-ness relative to risc-v spec
- check spir-v vs risc-v
- gpu structure
- opencl
- CUDA(R)
- change bits of address to 64-bit, to allow 16GB+ of memory
- (figure out a way to have asserts displayed over if it is the last run through the comb block before the flip-flops flip?)
- (maybe create a lint checker that tests taht if statements have)
- (add tests to bheavioral tests, that feed in `x`, and check caught somehow?)
- (out of order execution?)
- (use actual memory module?)

done:
- document generators
- document how the integer multiplication works
- move apu, mem.sv, proc_reg_wr_mux.sv, reg_file* test_mem.sv into prot folder
- rename toy_proc folder to verigpu
- move img to subfodler of doc
- update timing/run_yosys to be ble to hndle tasks (by wrapping in a module automatically)
- check if yosys can handle tasks
- check if yosys can handle functions
- add area approximation to timing.py (eg count the number of cells :P)
- move float add out of prot
- coding guidelines, plus what can go wrong with GLS etc
- float add
- merge some of the examples, eg test_store, test_out, test_load, test_addi
- sieve aratosthenes
- add slli, slri
- prime numbers calculator
- [older stuff truncated]

things for gpu:
- get_local_id(), get_global_id()
- barrier
- global mem
- local mem

things to ponder:
- how to read/write registry locking vector?
- use arbiter to request write access to registry file one cycle before writing?
- cases where we want to write:
   - LUI. have the data immediately, no need to wait for anything...
      - mind you, it's usually associated with an ADDI next. can we fuse them? (or bypass?)
   - ADDI. need a cycle to load rs
   - LOAD. need lots of cycles to retrieve from memory. we dont know in advance which cycle the data will arrive, but it
     takes so long, so an extra cycle, who cares?
     - for reading from cache, it's faster, but we probably know better when the data will arrive? (?)
   - DIV: we know when the data will arrive, since we count down the pos
   - various other immediate ops: need at least one cycle to load rs1, rs2    
