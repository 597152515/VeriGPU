- int division
- int modulus
- fuse div and modulus instructions somehow, in the pipeline
- parallel instruction execution
- add area approximation to timing.py (eg count the number of cells :P)
- floats:  mul, div, modulus, add, sub, beq, glt
- rename examples....
- matrix multiplication
- verilator driver file
- prime numbers calculator
- maybe use a C/C++ -> RISC-V compiler, instead of writing assembler?
- instruction cache
- out of order execution
- check endian-ness relative to risc-v spec
- check spir-v vs risc-v
- gpu structure
- opencl
- change bits of address to 64-bit, to allow 16GB+ of memory
- create register file
- (use actual memory module?)

done:
- add cicd to readme
- tested store and load floats
- fout.s; and modify assembler to handle floats for li
- cicd for iverilog reg_test
- cicd for timing
- cicd for verilator compilation
- lui
- change time units to clock cycles
- fix stdout in circleci
- factorial calculator
- int multiplication
- measure timing/maximum clock speed somehow
- handle assigns in timing.py
- [older stuff truncated]

things for gpu:
- get_local_id(), get_global_id()
- barrier
- global mem
- local mem

notes:
- I-type: register-immediate, rs1 . imm => rd (includes loads, where address is rs1 + signed offset)
- R-type: register-register operations, rs1 . rs2 => rd
- J-type: jumps. address in register + immediate offset
- B-type: conditional branches (offsets are in multiples of 2 bytes); based on rs1 and rs2; funct specifies eg BEQ, or BNE
- S-type: stores; rs2 is copied into memory. address is from rs1 + signed offset.
